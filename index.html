<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Constructor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Montserrat:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #1A1A1E;
            --bg-panel: rgba(255, 255, 255, 0.05);
            --text-primary: #E0E0E0;
            --text-heading: #FFFFFF;
            --accent-gold: #D4AF37;
            --accent-silver: #C0C0C0;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --border: 1px solid rgba(255, 255, 255, 0.1);
            --button-secondary-bg: #2A2A2E;
            --button-secondary-border: #D4AF37;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 30px;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            gap: 40px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .section {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 25px;
            box-shadow: var(--shadow);
            border: var(--border);
            transition: opacity 0.3s ease;
        }

        .section-header {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 12px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            transition: background 0.3s ease;
        }

        .section-header:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .section-header h2 {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            font-size: 20px;
            color: var(--text-heading);
            flex-grow: 1;
        }

        .section-content {
            display: none;
            padding: 25px 0;
        }

        .section-content.active {
            display: block;
        }

        .status {
            margin: 15px 0;
            color: var(--text-primary);
            font-size: 16px;
        }

        .error {
            color: #FF4D4D;
        }

        .progress {
            margin: 15px 0;
            color: var(--text-primary);
            font-size: 16px;
            display: none;
        }

        .progress.active {
            display: block;
        }

        .instructions {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
        }

        .instructions h3 {
            margin: 0 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            color: var(--text-heading);
        }
        
        
        

        .video-container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            align-items: flex-start;
        }

        .video-wrapper, .canvas-wrapper {
            position: relative;
            flex: 1;
            min-width: 300px;
        }

        video {
            width: 100%;
            max-width: 640px;
            border-radius: 8px;
            border: var(--border);
            box-shadow: var(--shadow);
        }

        canvas {
            border-radius: 8px;
            border: var(--border);
            box-shadow: var(--shadow);
        }

        .source-canvas {
            width: 100%;
            max-width: 640px;
        }

        .target-canvas {
            background: black;
            width: 100%;
            max-width: 100%;
        }

        .hidden-canvas {
            position: absolute;
            left: -9999px;
            top: -9999px;
        }

        .controls {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .timeline {
            position: relative;
            height: 30px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            margin: 25px 0;
            transition: background 0.3s ease;
        }

        .timeline-range {
            position: absolute;
            background: var(--accent-gold);
            height: 100%;
            opacity: 0.7;
            border-radius: 8px;
        }

        .fragment-range {
            position: absolute;
            background: #FF4D4D;
            height: 10px;
            top: 10px;
            opacity: 0.7;
            border-radius: 4px;
        }

        .handle {
            position: absolute;
            width: 12px;
            height: 30px;
            background: var(--accent-silver);
            border-radius: 4px;
            cursor: ew-resize;
            transition: background 0.3s ease;
        }

        .handle:hover {
            background: var(--accent-gold);
        }

        .fragment-list {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            border: var(--border);
            border-radius: 8px;
            padding: 10px;
            background: var(--bg-panel);
        }

        .fragment-list-header {
            display: flex;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.08);
            border-bottom: var(--border);
            font-weight: 600;
            font-size: 14px;
            color: var(--text-heading);
        }

        .fragment-list-header div {
            flex: 1;
            text-align: center;
        }

        .fragment-list-header .name {
            flex: 2;
            text-align: left;
        }

        .fragment-list-header .lock {
            flex: 0.5;
        }

        .fragment-list-header .action {
            flex: 0.5;
        }

        .fragment-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 5px 0;
            background: var(--bg-panel);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        .fragment-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .fragment-item.active {
            background: #d4af37ab;
            color: #1A1A1E;
        }

        .fragment-item .name {
            flex: 2;
            text-align: left;
            font-size: 16px;
        }

        .fragment-item .timing {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fragment-item .lock {
            flex: 0.5;
            text-align: center;
        }

        .fragment-item .action {
            flex: 0.5;
            text-align: center;
        }

        .fragment-item input[type="checkbox"] {
            margin: 0 5px;
            accent-color: var(--accent-gold);
        }

        .fragment-item input[type="text"] {
            width: 60px;
            padding: 6px;
            margin: 0 5px;
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .fragment-item input[type="text"]:focus {
            border-color: var(--accent-silver);
            outline: none;
        }

        .fragment-item .lock-btn, .fragment-item .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-primary);
            transition: color 0.3s ease, transform 0.3s ease;
        }

        .fragment-item .lock-btn:hover, .fragment-item .action-btn:hover {
            color: var(--accent-gold);
            transform: translateY(-2px);
        }

        .fragment-controls {
            margin-top: 25px;
            padding: 15px;
            border: var(--border);
            border-radius: 12px;
            background: var(--bg-panel);
            box-shadow: var(--shadow);
        }

        .control-header {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 12px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            transition: background 0.3s ease;
        }

        .control-header:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .control-header h2 {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            font-size: 18px;
            color: var(--text-heading);
            flex-grow: 1;
        }

        .control-content {
            display: none;
        }

        .control-content.active {
            display: block;
        }

        .control-block {
            margin-bottom: 25px;
        }

        .control-block h3 {
            margin: 0 0 10px;
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            color: var(--text-heading);
            border-bottom: 1px solid var(--accent-gold);
            padding-bottom: 5px;
        }

        .control-block-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
        }

        .control-block-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        .fragment-controls label {
            display: block;
            font-size: 14px;
            margin-bottom: 5px;
            color: var(--text-heading);
        }

        .fragment-controls input, .fragment-controls select {
            width: 90%;
            padding: 8px;
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 14px;
            transition: border-color 0.3s ease, background 0.3s ease;
        }

        .fragment-controls select {
            background: var(--button-secondary-bg);
            border: 2px solid var(--button-secondary-border);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23D4AF37" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 30px;
        }

        .fragment-controls select:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--accent-silver);
        }

        .fragment-controls select:focus {
            border-color: var(--accent-silver);
            outline: none;
        }

        .fragment-controls input:focus {
            border-color: var(--accent-silver);
            outline: none;
        }

        .fragment-controls input:disabled, .fragment-controls select:disabled {
            background: rgba(255, 255, 255, 0.03);
            cursor: not-allowed;
        }

        .fragment-controls button {
            width: 100%;
            padding: 10px;
            background: var(--accent-gold);
            color: #1A1A1E;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        }

        .fragment-controls button:hover {
            background: var(--accent-silver);
            transform: translateY(-2px);
            box-shadow: 0 0 10px rgba(212, 160, 23, 0.3);
        }

        .file-upload-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-upload-wrapper input[type="file"] {
            opacity: 0;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            cursor: pointer;
        }

        .custom-button,
        .file-upload-wrapper button {
            padding: 10px 20px;
            background: var(--accent-gold);
            color: #1A1A1E;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* Стили наведения для всех кнопок */
        .custom-button:hover,
        .file-upload-wrapper button:hover {
            background: var(--accent-silver);
            transform: translateY(-2px);
            box-shadow: 0 0 10px rgba(212, 160, 23, 0.3);
        }
        
        /* Модификатор для второстепенных кнопок */
        .custom-button.secondary {
            background: var(--button-secondary-bg);
            color: var(--text-primary);
            border: 2px solid var(--button-secondary-border);
        }
        
        /* Наведение для второстепенных кнопок */
        .custom-button.secondary:hover {
            background: var(--accent-silver);
            color: #1A1A1E;
            border-color: var(--accent-silver);
        }
        
        /* Flex-стили для кнопок с иконками в .controls */
        .controls .custom-button {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .controls .time-input-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            width: 100px;
        }

        .controls .time-input-wrapper input[type="text"] {
            width: 100%;
            padding: 8px 8px 8px 30px;
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .controls .time-input-wrapper input[type="text"]:focus {
            border-color: var(--accent-silver);
            outline: none;
        }

        .controls .time-input-wrapper i {
            position: absolute;
            left: 8px;
            color: var(--accent-gold);
            font-size: 14px;
        }

        #export {
            padding: 12px 30px;
            background: var(--accent-gold);
            color: #1A1A1E;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #export:hover {
            background: var(--accent-silver);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(212, 160, 23, 0.5);
        }

        #cancel-export {
            padding: 10px 20px;
            background: var(--button-secondary-bg);
            color: var(--text-primary);
            border: 2px solid var(--button-secondary-border);
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        }

        #cancel-export:hover {
            background: var(--accent-silver);
            color: #1A1A1E;
            border-color: var(--accent-silver);
            transform: translateY(-2px);
            box-shadow: 0 0 10px rgba(212, 160, 23, 0.3);
        }

        @media (max-width: 600px) {
            .control-block-grid {
                grid-template-columns: 1fr;
            }
            .fragment-item {
                flex-wrap: wrap;
            }
            .fragment-list-header, .fragment-item {
                font-size: 12px;
            }
            .fragment-item input[type="text"] {
                width: 50px;
            }
            .file-upload-wrapper button {
                padding: 8px 16px;
                font-size: 12px;
            }
            .controls .custom-button {
                padding: 8px 16px;
                font-size: 12px;
            }
            #export {
                padding: 10px 20px;
                font-size: 14px;
            }
            .instructions {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Upload Section -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>Upload Video</h2>
            <i class="fas fa-chevron-down"></i>
        </div>
        <div class="section-content active">
            <div class="file-upload-wrapper">
                <button class="custom-button"><i class="fas fa-upload"></i> Choose Video</button>
                <input type="file" id="video-upload" accept="video/mp4,video/webm">
            </div>
            <div class="instructions-container">
                <div class="description">
                    <h3>About the Program</h3>
                    <p>
                        This program is designed to help you edit and format videos for mobile devices. Its main purpose is to create optimized video fragments that fit perfectly on mobile screens, ensuring a seamless viewing experience.
                    </p>
                    <p><strong>Key Features:</strong></p>
                    <ul>
                        <li>Upload videos in MP4 format and split them into fragments.</li>
                        <li>Adjust fragment positions and sizes for mobile-friendly viewing.</li>
                        <li>Preview and fine-tune fragments with easy-to-use controls.</li>
                        <li>Export your edited video in WebM format for mobile compatibility.</li>
                    </ul>
                </div>
                <div class="instructions">
                    <h3>How to Use</h3>
                    <ol>
                        <li>Upload a video using the <strong>"Choose Video"</strong> button (in MP4 format).</li>
                        <li>On the <strong>"Source Video"</strong> tab, add fragments for formatting the video for a mobile screen by clicking <strong>"Add Fragments"</strong>.</li>
                        <li>On the additional video panel, adjust the position and size of the fragment (only the fragment selected in the list can be edited).</li>
                        <li>Go to the <strong>"Target Video"</strong> tab and arrange the fragments for convenient viewing on a mobile device (only the fragment selected in the list can be edited; use the mouse wheel to adjust the size).</li>
                        <li>On the <strong>"Fragment Controls"</strong> tab, you can also quickly center the fragment in the target video, reset the scale, or fit the fragment to the dimensions.</li>
                        <li>After arranging the fragments, click the <strong>"Process & Download"</strong> button to export the result in WebM format.</li>
                    </ol>
                </div>
            </div>
            <div id="status" class="status"></div>
        </div>
    </div>

    <!-- Source Video Section -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>Source Video</h2>
            <i class="fas fa-chevron-down"></i>
        </div>
        <div class="section-content active">
            <div class="video-container">
                <div class="video-wrapper">
                    <video id="source-video" controls></video>
                    <canvas id="source-canvas" class="source-canvas"></canvas>
                </div>
                    <div class="controls">
                        <button class="custom-button secondary" id="play-pause" aria-label="Play or pause video"><i class="fas fa-play"></i> Play/Pause</button>
                        <input type="range" id="seek-bar" min="0" value="0" aria-label="Seek video timeline">
                        <span id="current-time">00:00</span>
                        <div class="time-input-wrapper">
                            <i class="fas fa-clock"></i>
                            <input type="text" id="start-time-input" placeholder="mm:ss" aria-label="Set fragment start time">
                        </div>
                        <div class="time-input-wrapper">
                            <i class="fas fa-clock"></i>
                            <input type="text" id="end-time-input" placeholder="mm:ss" aria-label="Set fragment end time">
                        </div>
                        <button class="custom-button" id="add-fragment" aria-label="Add new video fragment"><i class="fas fa-plus"></i> Add Fragment</button>
                        <div class="file-upload-wrapper">
                            <button class="custom-button secondary" id="export-fragments" aria-label="Export fragments to JSON"><i class="fas fa-download"></i> Export</button>
                        </div>
                        <div class="file-upload-wrapper">
                            <button class="custom-button secondary" id="import-fragments-btn" aria-label="Import fragments from JSON"><i class="fas fa-upload"></i> Import </button>
                        </div>
                        <input type="file" id="import-fragments" accept="application/json" style="display: none;">
                    </div>
                </div>
            <div class="timeline" id="source-timeline">
                <div class="timeline-range" id="timeline-range"></div>
                <div class="handle" id="start-handle"></div>
                <div class="handle" id="end-handle"></div>
                <div class="handle" id="seek-handle" style="background: #FF4D4D;"></div>
            </div>
            <div class="fragment-list-header">
                <div class="name">Fragment Name</div>
                <div class="timing">Start</div>
                <div class="timing">End</div>
                <div class="lock">Lock</div>
                <div class="action">Duplicate</div>
                <div class="action">Delete</div>
            </div>
            <div class="fragment-list" id="fragment-list"></div>
            <div class="fragment-controls" id="fragment-controls">
                <div class="control-header" onclick="toggleControls(this)">
                    <h2>Fragment Controls</h2>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="control-content active"></div>
            </div>
            </div>
        </div>
    </div>

    <!-- Target Video Section -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>Target Video</h2>
            <i class="fas fa-chevron-down"></i>
        </div>
        <div class="section-content active">
            <div class="video-container">
                <div class="canvas-wrapper">
                    <canvas id="target-canvas" class="target-canvas"></canvas>
                    <canvas id="hidden-canvas" class="hidden-canvas"></canvas>
                </div>
            </div>
            <div class="controls">
                <button class="custom-button secondary" id="preview-play-pause"><i class="fas fa-play"></i> Preview</button>
                <input type="range" id="preview-seek" min="0" value="0">
                <span id="preview-time">00:00</span>
                <select id="canvas-format">
                    <option value="540x960">Phone (540x960)</option>
                    <option value="720x720">Square (720x720)</option>
                    <option value="1280x720">HD (1280x720)</option>
                    <option value="1920x1080">Full HD (1920x1080)</option>
                    <option value="custom">Custom</option>
                </select>
                <input type="number" id="canvas-width" placeholder="Width" min="100" style="width: 80px; display: none;">
                <input type="number" id="canvas-height" placeholder="Height" min="100" style="width: 80px; display: none;">
                <button id="export" class="custom-button"><i class="fas fa-file-video"></i> Process & Download</button>
                <button id="cancel-export" class="custom-button secondary" style="display: none;">Cancel</button>
            </div>
            <div id="export-progress" class="progress">Exporting: 0%</div>
        </div>
    </div>

    <script>
        let video = document.getElementById('source-video');
        const sourceCanvas = document.getElementById('source-canvas');
        const targetCanvas = document.getElementById('target-canvas');
        const hiddenCanvas = document.getElementById('hidden-canvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const targetCtx = targetCanvas.getContext('2d');
        const hiddenCtx = hiddenCanvas.getContext('2d');
        const uploadInput = document.getElementById('video-upload');
        const status = document.getElementById('status');
        const playPauseBtn = document.getElementById('play-pause');
        const seekBar = document.getElementById('seek-bar');
        const currentTime = document.getElementById('current-time');
        const startTimeInput = document.getElementById('start-time-input');
        const endTimeInput = document.getElementById('end-time-input');
        const addFragmentBtn = document.getElementById('add-fragment');
        const exportFragmentsBtn = document.getElementById('export-fragments');
        const importFragmentsInput = document.getElementById('import-fragments');
        const importFragmentsBtn = document.getElementById('import-fragments-btn');
        const timeline = document.getElementById('source-timeline');
        const timelineRange = document.getElementById('timeline-range');
        const startHandle = document.getElementById('start-handle');
        const endHandle = document.getElementById('end-handle');
        const seekHandle = document.getElementById('seek-handle');
        const fragmentList = document.getElementById('fragment-list');
        const fragmentControls = document.getElementById('fragment-controls');
        const previewPlayPauseBtn = document.getElementById('preview-play-pause');
        const previewSeek = document.getElementById('preview-seek');
        const previewTime = document.getElementById('preview-time');
        const exportBtn = document.getElementById('export');
        const cancelExportBtn = document.getElementById('cancel-export');
        const canvasFormatSelect = document.getElementById('canvas-format');
        const canvasWidthInput = document.getElementById('canvas-width');
        const canvasHeightInput = document.getElementById('canvas-height');
        const exportProgress = document.getElementById('export-progress');

        let fragments = [];
        let activeFragment = null;
        let startTime = 0;
        let endTime = 0;
        let isDragging = false;
        let isResizing = false;
        let isDraggingTarget = false;
        let undoStack = [];
        let isPreviewing = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let audioCtx = null;
        let audioSource = null;
        let audioDestination = null;
        let videoDuration = 0;
        let isResizingTopLeft = false;
        let isResizingPoint = false;
        let videoStream = null;
        let audioStream = null;
        let isExporting = false;
        let videoSrc = '';
        let dragStartX = 0;
        let dragStartY = 0;

        // Инициализация размеров canvas
        let targetCanvasWidth = 540;
        let targetCanvasHeight = 960;
        let renderCanvasWidth = targetCanvasWidth;
        let renderCanvasHeight = targetCanvasHeight;

        // Установка начальных размеров canvas
        targetCanvas.width = targetCanvasWidth;
        targetCanvas.height = targetCanvasHeight;
        targetCanvas.style.width = `${targetCanvasWidth}px`;
        targetCanvas.style.height = `${targetCanvasHeight}px`;
        hiddenCanvas.width = renderCanvasWidth;
        hiddenCanvas.height = renderCanvasHeight;

        function updateCanvasSize(width, height) {
            renderCanvasWidth = width;
            renderCanvasHeight = height;
            hiddenCanvas.width = width;
            hiddenCanvas.height = height;

            // Адаптация видимого canvas с сохранением пропорций
            const containerWidth = document.querySelector('.canvas-wrapper').offsetWidth;
            const aspectRatio = width / height;
            let displayWidth = Math.min(containerWidth, width);
            let displayHeight = displayWidth / aspectRatio;

            // Проверка, чтобы высота не превышала контейнер, если контейнер ограничен по высоте
            const containerHeight = document.querySelector('.canvas-wrapper').offsetHeight || window.innerHeight;
            if (displayHeight > containerHeight) {
                displayHeight = containerHeight;
                displayWidth = displayHeight * aspectRatio;
            }

            targetCanvas.width = displayWidth;
            targetCanvas.height = displayHeight;
            targetCanvas.style.width = `${displayWidth}px`;
            targetCanvas.style.height = `${displayHeight}px`;

            // Масштабируем фрагменты для рендеринга
            const scaleX = width / targetCanvasWidth;
            const scaleY = height / targetCanvasHeight;
            fragments.forEach(frag => {
                frag.x = Math.min(frag.x * scaleX, width - frag.width * frag.scale);
                frag.y = Math.min(frag.y * scaleY, height - frag.height * frag.scale);
                frag.scale = frag.scale * Math.min(scaleX, scaleY);
            });

            targetCanvasWidth = width;
            targetCanvasHeight = height;

            updateFragmentControls();
            renderTargetFrame();
            status.textContent = `Canvas size updated to ${width}x${height}.`;
            status.classList.remove('error');
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('active');
            const icon = header.querySelector('i');
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-right');
        }

        function toggleControls(header) {
            const content = header.nextElementSibling;
            content.classList.toggle('active');
            const icon = header.querySelector('i');
            icon.classList.toggle('fa-chevron-down');
            icon.classList.toggle('fa-chevron-right');
        }

        function formatTime(seconds) {
            if (!seconds && seconds !== 0) return '00:00';
            const min = Math.floor(seconds / 60).toString().padStart(2, '0');
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }

        function parseTime(input) {
            const match = input.match(/^(\d+):(\d{2})$/);
            if (!match) return null;
            const min = parseInt(match[1]);
            const sec = parseInt(match[2]);
            if (sec >= 60) return null;
            return min * 60 + sec;
        }

        function roundToTwo(num) {
            return Math.round(num * 100) / 100;
        }

        function reinitializeVideoElement() {
            console.log('Reinitializing video element');
            videoSrc = video.src;
            const videoWrapper = video.parentElement;
            video.remove();
            video = document.createElement('video');
            video.id = 'source-video';
            video.controls = true;
            videoWrapper.insertBefore(video, sourceCanvas);
            if (videoSrc) {
                video.src = videoSrc;
                video.load();
                console.log('New video element initialized with source');
            }
            bindVideoEvents();
        }

        function bindVideoEvents() {
            video.addEventListener('timeupdate', () => {
                seekBar.value = video.currentTime;
                currentTime.textContent = formatTime(video.currentTime);
                if (isPreviewing) {
                    previewSeek.value = video.currentTime;
                    previewTime.textContent = formatTime(video.currentTime);
                }
                updateTimeline();
                renderSourceFrame();
                if (isPreviewing) renderTargetFrame();
            });

            video.onloadedmetadata = () => {
                videoDuration = video.duration;
                status.textContent = 'Video loaded successfully.';
                status.classList.remove('error');

                sourceCanvas.width = Math.min(video.videoWidth, 640);
                sourceCanvas.height = sourceCanvas.width * (video.videoHeight / video.videoWidth);
                video.width = sourceCanvas.width;
                video.height = sourceCanvas.height;

                startTime = 0;
                endTime = videoDuration;
                startTimeInput.value = formatTime(startTime);
                endTimeInput.value = formatTime(endTime);
                seekBar.max = videoDuration;
                previewSeek.max = videoDuration;

                fragments.forEach(frag => {
                    if (frag.bindEnd) {
                        frag.end = videoDuration;
                    }
                });

                updateFragmentList();
                updateTimeline();
                renderSourceFrame();
            };
        }

        uploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (!['video/mp4', 'video/webm'].includes(file.type)) {
                status.textContent = 'Error: Only MP4 or WebM formats are allowed.';
                status.classList.add('error');
                return;
            }

            const url = URL.createObjectURL(file);
            video.src = url;
            video.load();
        });

        exportFragmentsBtn.addEventListener('click', () => {
            if (fragments.length === 0) {
                status.textContent = 'No fragments to export.';
                status.classList.add('error');
                return;
            }
            const exportData = fragments.map(frag => ({
                sourceX: frag.sourceX,
                sourceY: frag.sourceY,
                width: frag.width,
                height: frag.height,
                x: frag.x,
                y: frag.y,
                scale: frag.scale,
                locked: frag.locked
            }));
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fragments.json';
            a.click();
            URL.revokeObjectURL(url);
            status.textContent = 'Fragments exported successfully.';
            status.classList.remove('error');
        });

        importFragmentsBtn.addEventListener('click', () => {
            importFragmentsInput.click();
        });

        importFragmentsInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedFragments = JSON.parse(event.target.result);
                    importedFragments.forEach(frag => {
                        fragments.push({
                            sourceX: frag.sourceX,
                            sourceY: frag.sourceY,
                            width: frag.width,
                            height: frag.height,
                            x: Math.min(frag.x, targetCanvasWidth - frag.width * frag.scale),
                            y: Math.min(frag.y, targetCanvasHeight - frag.height * frag.scale),
                            scale: frag.scale,
                            locked: frag.locked,
                            start: 0,
                            end: videoDuration || 10,
                            bindStart: false,
                            bindEnd: false
                        });
                    });
                    activeFragment = fragments[fragments.length - 1];
                    undoStack.push({ action: 'import', fragments: importedFragments });
                    updateFragmentList();
                    updateTimeline();
                    renderSourceFrame();
                    renderTargetFrame();
                    status.textContent = 'Fragments imported successfully.';
                    status.classList.remove('error');
                } catch (error) {
                    status.textContent = 'Error importing fragments: Invalid JSON.';
                    status.classList.add('error');
                }
                importFragmentsInput.value = '';
            };
            reader.readAsText(file);
        });

        canvasFormatSelect.addEventListener('change', () => {
            const value = canvasFormatSelect.value;
            if (value === 'custom') {
                canvasWidthInput.style.display = 'inline-block';
                canvasHeightInput.style.display = 'inline-block';
                canvasWidthInput.value = targetCanvasWidth;
                canvasHeightInput.value = targetCanvasHeight;
            } else {
                canvasWidthInput.style.display = 'none';
                canvasHeightInput.style.display = 'none';
                const [width, height] = value.split('x').map(Number);
                updateCanvasSize(width, height);
            }
        });

        canvasWidthInput.addEventListener('change', () => {
            const width = parseInt(canvasWidthInput.value);
            const height = parseInt(canvasHeightInput.value);
            if (width >= 100 && height >= 100) {
                updateCanvasSize(width, height);
            } else {
                status.textContent = 'Canvas dimensions must be at least 100x100.';
                status.classList.add('error');
            }
        });

        canvasHeightInput.addEventListener('change', () => {
            const width = parseInt(canvasWidthInput.value);
            const height = parseInt(canvasHeightInput.value);
            if (width >= 100 && height >= 100) {
                updateCanvasSize(width, height);
            } else {
                status.textContent = 'Canvas dimensions must be at least 100x100.';
                status.classList.add('error');
            }
        });

        playPauseBtn.addEventListener('click', togglePlayPause);
        function togglePlayPause() {
            if (video.paused) {
                video.play();
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Play/Pause';
            } else {
                video.pause();
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i> Play/Pause';
            }
        }

        seekBar.addEventListener('input', () => {
            video.currentTime = parseFloat(seekBar.value);
        });

        startTimeInput.addEventListener('change', () => {
            const time = parseTime(startTimeInput.value);
            if (time !== null && time >= 0 && time < endTime) {
                startTime = time;
                updateTimeline();
            } else {
                startTimeInput.value = formatTime(startTime);
                status.textContent = 'Invalid start time.';
                status.classList.add('error');
            }
        });

        endTimeInput.addEventListener('change', () => {
            const time = parseTime(endTimeInput.value);
            if (time !== null && time <= videoDuration && time > startTime) {
                endTime = time;
                updateTimeline();
            } else {
                endTimeInput.value = formatTime(endTime);
                status.textContent = 'Invalid end time.';
                status.classList.add('error');
            }
        });

        function updateTimeline() {
            const width = timeline.offsetWidth;
            const startPercent = (startTime / videoDuration) * 100;
            const endPercent = (endTime / videoDuration) * 100;
            const currentPercent = (video.currentTime / videoDuration) * 100;

            timelineRange.style.left = `${startPercent}%`;
            timelineRange.style.width = `${endPercent - startPercent}%`;

            startHandle.style.left = `${startPercent}%`;
            endHandle.style.left = `${endPercent}%`;
            seekHandle.style.left = `${currentPercent}%`;

            fragments.forEach((frag, i) => {
                const fragStartPercent = (frag.bindStart ? 0 : frag.start / videoDuration) * 100;
                const fragEndPercent = (frag.bindEnd ? 100 : frag.end / videoDuration) * 100;
                const fragEl = document.getElementById(`fragment-range-${i}`);
                if (fragEl) {
                    fragEl.style.left = `${fragStartPercent}%`;
                    fragEl.style.width = `${fragEndPercent - fragStartPercent}%`;
                }
            });
        }

        let dragHandle = null;
        startHandle.addEventListener('mousedown', () => dragHandle = 'start');
        endHandle.addEventListener('mousedown', () => dragHandle = 'end');
        seekHandle.addEventListener('mousedown', () => dragHandle = 'seek');

        document.addEventListener('mousemove', (e) => {
            if (!dragHandle) return;
            const rect = timeline.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const time = pos * videoDuration;

            if (dragHandle === 'start' && time < endTime && time >= 0) {
                startTime = time;
                startTimeInput.value = formatTime(startTime);
            } else if (dragHandle === 'end' && time > startTime && time <= videoDuration) {
                endTime = time;
                endTimeInput.value = formatTime(endTime);
            } else if (dragHandle === 'seek') {
                video.currentTime = time;
            }
            updateTimeline();
        });

        document.addEventListener('mouseup', () => {
            dragHandle = null;
        });

        addFragmentBtn.addEventListener('click', addFragment);
        function addFragment() {
            const fragment = {
                sourceX: video.videoWidth ? video.videoWidth / 4 : 100,
                sourceY: video.videoHeight ? video.videoHeight / 4 : 100,
                width: video.videoWidth ? Math.min(100, video.videoWidth / 2) : 100,
                height: video.videoHeight ? Math.min(100, video.videoHeight / 2) : 100,
                x: (targetCanvasWidth - 100) / 2,
                y: (targetCanvasHeight - 100) / 2,
                scale: 1,
                start: startTime,
                end: endTime,
                bindStart: false,
                bindEnd: false,
                locked: false
            };
            fragments.push(fragment);
            activeFragment = fragment;
            undoStack.push({ action: 'add', fragment });
            updateFragmentList();
            updateTimeline();
            renderSourceFrame();
            renderTargetFrame();
        }

        function updateFragmentList() {
            fragmentList.innerHTML = '';
            fragments.forEach((frag, i) => {
                const div = document.createElement('div');
                div.className = 'fragment-item';
                if (frag === activeFragment) div.className += ' active';
                div.onclick = () => {
                    if (frag === activeFragment) return;
                    activeFragment = frag;
                    updateFragmentList();
                    updateFragmentControls();
                    renderSourceFrame();
                    renderTargetFrame();
                };

                const nameDiv = document.createElement('div');
                nameDiv.className = 'name';
                nameDiv.textContent = `Fragment ${i + 1}`;
                div.appendChild(nameDiv);

                const startDiv = document.createElement('div');
                startDiv.className = 'timing';
                const startCheckbox = document.createElement('input');
                startCheckbox.type = 'checkbox';
                startCheckbox.checked = frag.bindStart;
                startCheckbox.disabled = frag.locked;
                startCheckbox.title = 'Bind to video start';
                startCheckbox.onchange = () => {
                    if (frag.locked) return;
                    undoStack.push({
                        action: 'edit',
                        fragment: frag,
                        key: 'bindStart',
                        oldValue: frag.bindStart
                    });
                    frag.bindStart = startCheckbox.checked;
                    if (frag.bindStart) {
                        frag.start = 0;
                    }
                    updateFragmentList();
                    updateTimeline();
                    renderTargetFrame();
                };
                startDiv.appendChild(startCheckbox);

                const startInput = document.createElement('input');
                startInput.type = 'text';
                startInput.value = formatTime(frag.bindStart ? 0 : frag.start);
                startInput.disabled = frag.bindStart || frag.locked;
                startInput.onchange = () => {
                    if (frag.locked || frag.bindStart) return;
                    const time = parseTime(startInput.value);
                    if (time !== null && time >= 0 && time < (frag.bindEnd ? videoDuration : frag.end)) {
                        undoStack.push({
                            action: 'edit',
                            fragment: frag,
                            key: 'start',
                            oldValue: frag.start
                        });
                        frag.start = time;
                        updateFragmentList();
                        updateTimeline();
                        renderTargetFrame();
                    } else {
                        startInput.value = formatTime(frag.start);
                        status.textContent = 'Invalid start time.';
                        status.classList.add('error');
                    }
                };
                startDiv.appendChild(startInput);
                div.appendChild(startDiv);

                const endDiv = document.createElement('div');
                endDiv.className = 'timing';
                const endCheckbox = document.createElement('input');
                endCheckbox.type = 'checkbox';
                endCheckbox.checked = frag.bindEnd;
                endCheckbox.disabled = frag.locked;
                endCheckbox.title = 'Bind to video end';
                endCheckbox.onchange = () => {
                    if (frag.locked) return;
                    undoStack.push({
                        action: 'edit',
                        fragment: frag,
                        key: 'bindEnd',
                        oldValue: frag.bindEnd
                    });
                    frag.bindEnd = endCheckbox.checked;
                    if (frag.bindEnd) {
                        frag.end = videoDuration;
                    }
                    updateFragmentList();
                    updateTimeline();
                    renderTargetFrame();
                };
                endDiv.appendChild(endCheckbox);

                const endInput = document.createElement('input');
                endInput.type = 'text';
                endInput.value = formatTime(frag.bindEnd ? videoDuration : frag.end);
                endInput.disabled = frag.bindEnd || frag.locked;
                endInput.onchange = () => {
                    if (frag.locked || frag.bindEnd) return;
                    const time = parseTime(endInput.value);
                    if (time !== null && time <= videoDuration && time > (frag.bindStart ? 0 : frag.start)) {
                        undoStack.push({
                            action: 'edit',
                            fragment: frag,
                            key: 'end',
                            oldValue: frag.end
                        });
                        frag.end = time;
                        updateFragmentList();
                        updateTimeline();
                        renderTargetFrame();
                    } else {
                        endInput.value = formatTime(frag.end);
                        status.textContent = 'Invalid end time.';
                        status.classList.add('error');
                    }
                };
                endDiv.appendChild(endInput);
                div.appendChild(endDiv);

                const lockDiv = document.createElement('div');
                lockDiv.className = 'lock';
                const lockBtn = document.createElement('button');
                lockBtn.className = 'lock-btn';
                lockBtn.innerHTML = `<i class="fas ${frag.locked ? 'fa-lock' : 'fa-unlock'}"></i>`;
                lockBtn.onclick = () => {
                    undoStack.push({ action: 'lock', fragment: frag, oldLocked: frag.locked });
                    frag.locked = !frag.locked;
                    lockBtn.innerHTML = `<i class="fas ${frag.locked ? 'fa-lock' : 'fa-unlock'}"></i>`;
                    if (frag.locked && frag === activeFragment) {
                        activeFragment = fragments.find(f => !f.locked) || null;
                    }
                    updateFragmentList();
                    updateFragmentControls();
                    renderSourceFrame();
                    renderTargetFrame();
                };
                lockDiv.appendChild(lockBtn);
                div.appendChild(lockDiv);

                const dupDiv = document.createElement('div');
                dupDiv.className = 'action';
                const dupBtn = document.createElement('button');
                dupBtn.className = 'action-btn';
                dupBtn.innerHTML = `<i class="fas fa-copy"></i>`;
                dupBtn.disabled = frag.locked;
                dupBtn.title = 'Duplicate';
                dupBtn.onclick = () => {
                    if (frag.locked) return;
                    const newFragment = { ...frag, scale: roundToTwo(frag.scale), locked: false };
                    fragments.push(newFragment);
                    activeFragment = newFragment;
                    undoStack.push({ action: 'add', fragment: newFragment });
                    updateFragmentList();
                    updateTimeline();
                    renderSourceFrame();
                    renderTargetFrame();
                };
                dupDiv.appendChild(dupBtn);
                div.appendChild(dupDiv);

                const delDiv = document.createElement('div');
                delDiv.className = 'action';
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.innerHTML = `<i class="fas fa-trash"></i>`;
                delBtn.disabled = frag.locked;
                delBtn.title = 'Delete';
                delBtn.onclick = () => {
                    if (frag.locked) return;
                    const index = fragments.indexOf(frag);
                    fragments.splice(index, 1);
                    undoStack.push({ action: 'remove', fragment: frag, index });
                    activeFragment = fragments.find(f => !f.locked) || null;
                    updateFragmentList();
                    updateTimeline();
                    renderSourceFrame();
                    renderTargetFrame();
                };
                delDiv.appendChild(delBtn);
                div.appendChild(delDiv);

                fragmentList.appendChild(div);

                const fragRange = document.createElement('div');
                fragRange.className = 'fragment-range';
                fragRange.id = `fragment-range-${i}`;
            });
            updateFragmentControls();
        }

        function updateFragmentControls() {
            const content = fragmentControls.querySelector('.control-content');
            content.innerHTML = '';
            if (!activeFragment) return;

            const sourceBlock = document.createElement('div');
            sourceBlock.className = 'control-block';
            sourceBlock.innerHTML = '<h3>Source Format</h3><div class="control-block-grid"></div>';
            const sourceGrid = sourceBlock.querySelector('.control-block-grid');

            const targetBlock = document.createElement('div');
            targetBlock.className = 'control-block';
            targetBlock.innerHTML = '<h3>Target Format</h3><div class="control-block-grid"></div>';
            const targetGrid = targetBlock.querySelector('.control-block-grid');

            const buttonBlock = document.createElement('div');
            buttonBlock.className = 'control-block';
            buttonBlock.innerHTML = '<h3>Actions</h3><div class="control-block-buttons"></div>';
            const buttonGrid = buttonBlock.querySelector('.control-block-buttons');

            const fields = [
                { label: 'Source X', key: 'sourceX', type: 'number', min: 0, max: video.videoWidth || 1000, block: sourceGrid },
                { label: 'Source Y', key: 'sourceY', type: 'number', min: 0, max: video.videoHeight || 1000, block: sourceGrid },
                { label: 'Width', key: 'width', type: 'number', min: 10, max: video.videoWidth || 1000, block: sourceGrid },
                { label: 'Height', key: 'height', type: 'number', min: 10, max: video.videoHeight || 1000, block: sourceGrid },
                { label: 'Target X', key: 'x', type: 'number', min: 0, max: targetCanvasWidth, block: targetGrid },
                { label: 'Target Y', key: 'y', type: 'number', min: 0, max: targetCanvasHeight, block: targetGrid },
                { label: 'Scale', key: 'scale', type: 'number', min: 0.1, step: 0.01, block: targetGrid }
            ];

            fields.forEach(field => {
                const div = document.createElement('div');
                div.innerHTML = `<label>${field.label}</label>`;
                const input = document.createElement('input');
                input.type = field.type;
                if (field.min !== undefined) input.min = field.min;
                if (field.max !== undefined) input.max = field.max;
                if (field.step) input.step = field.step;
                input.value = roundToTwo(activeFragment[field.key]);
                input.disabled = activeFragment.locked;
                input.onchange = () => {
                    if (activeFragment.locked) return;
                    const value = parseFloat(input.value);
                    if (!isNaN(value)) {
                        if (field.key === 'scale' && value >= 0.1) {
                            undoStack.push({ action: 'edit', fragment: activeFragment, key: field.key, oldValue: activeFragment[field.key] });
                            activeFragment[field.key] = roundToTwo(value);
                        } else if (field.min <= value && value <= field.max) {
                            undoStack.push({ action: 'edit', fragment: activeFragment, key: field.key, oldValue: activeFragment[field.key] });
                            activeFragment[field.key] = value;
                        }
                    }
                    input.value = roundToTwo(activeFragment[field.key]);
                    renderSourceFrame();
                    renderTargetFrame();
                };
                div.appendChild(input);
                field.block.appendChild(div);
            });

            const buttons = [
                { label: 'Center', action: centerFragment },
                { label: 'Reset Scale', action: resetFragmentScale },
                { label: 'Fit', action: fitFragment }
            ];

            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.textContent = btn.label;
                button.disabled = activeFragment.locked;
                button.onclick = () => {
                    if (!activeFragment.locked) btn.action();
                };
                buttonGrid.appendChild(button);
            });

            content.appendChild(sourceBlock);
            content.appendChild(targetBlock);
            content.appendChild(buttonBlock);
        }

        function centerFragment() {
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'x', oldValue: activeFragment.x });
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'y', oldValue: activeFragment.y });
            activeFragment.x = (targetCanvasWidth - activeFragment.width * activeFragment.scale) / 2;
            activeFragment.y = (targetCanvasHeight - activeFragment.height * activeFragment.scale) / 2;
            updateFragmentControls();
            renderTargetFrame();
        }

        function resetFragmentScale() {
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'scale', oldValue: activeFragment.scale });
            activeFragment.scale = 1;
            updateFragmentControls();
            renderTargetFrame();
        }

        function fitFragment() {
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'scale', oldValue: activeFragment.scale });
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'x', oldValue: activeFragment.x });
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'y', oldValue: activeFragment.y });
            activeFragment.scale = roundToTwo(targetCanvasWidth / activeFragment.width);
            activeFragment.x = (targetCanvasWidth - activeFragment.width * activeFragment.scale) / 2;
            activeFragment.y = (targetCanvasHeight - activeFragment.height * activeFragment.scale) / 2;
            updateFragmentControls();
            renderTargetFrame();
        }

        function renderSourceFrame() {
            sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
            sourceCtx.drawImage(video, 0, 0, sourceCanvas.width, sourceCanvas.height);

            fragments.forEach(frag => {
                const scaleX = sourceCanvas.width / (video.videoWidth || 1000);
                const scaleY = sourceCanvas.height / (video.videoHeight || 1000);
                sourceCtx.strokeStyle = frag === activeFragment ? 'red' : 'blue';
                sourceCtx.lineWidth = 2;
                sourceCtx.strokeRect(
                    frag.sourceX * scaleX,
                    frag.sourceY * scaleY,
                    frag.width * scaleX,
                    frag.height * scaleY
                );

                if (frag === activeFragment && !frag.locked) {
                    const x = (frag.sourceX + frag.width) * scaleX;
                    const y = (frag.sourceY + frag.height) * scaleY;
                    sourceCtx.fillStyle = 'red';
                    sourceCtx.beginPath();
                    sourceCtx.arc(x, y, 5, 0, 2 * Math.PI);
                    sourceCtx.fill();
                }
            });
        }

        function renderTargetFrame() {
            const displayScaleX = targetCanvas.width / renderCanvasWidth;
            const displayScaleY = targetCanvas.height / renderCanvasHeight;

            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            targetCtx.fillStyle = 'black';
            targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);

            hiddenCtx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            hiddenCtx.fillStyle = 'black';
            hiddenCtx.fillRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

            fragments.forEach(frag => {
                const fragStart = frag.bindStart ? 0 : frag.start;
                const fragEnd = frag.bindEnd ? videoDuration : frag.end;
                if (video.currentTime >= fragStart && video.currentTime <= fragEnd) {
                    targetCtx.drawImage(
                        video,
                        frag.sourceX, frag.sourceY, frag.width, frag.height,
                        frag.x * displayScaleX, frag.y * displayScaleY,
                        frag.width * frag.scale * displayScaleX, frag.height * frag.scale * displayScaleY
                    );
                    hiddenCtx.drawImage(
                        video,
                        frag.sourceX, frag.sourceY, frag.width, frag.height,
                        frag.x, frag.y, frag.width * frag.scale, frag.height * frag.scale
                    );
                }
                if (frag === activeFragment) {
                    targetCtx.strokeStyle = 'red';
                    targetCtx.lineWidth = 2;
                    targetCtx.strokeRect(
                        frag.x * displayScaleX, frag.y * displayScaleY,
                        frag.width * frag.scale * displayScaleX, frag.height * frag.scale * displayScaleY
                    );
                }
            });
        }

        sourceCanvas.addEventListener('mousedown', (e) => {
            if (!activeFragment || activeFragment.locked) return;
            const rect = sourceCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (video.videoWidth / sourceCanvas.width);
            const y = (e.clientY - rect.top) * (video.videoHeight / sourceCanvas.height);

            const inScalePoint = Math.hypot(x - (activeFragment.sourceX + activeFragment.width), y - (activeFragment.sourceY + activeFragment.height)) < 8;
            const inCenter = x >= activeFragment.sourceX && x <= activeFragment.sourceX + activeFragment.width &&
                             y >= activeFragment.sourceY && y <= activeFragment.sourceY + activeFragment.height;
            const inTopLeft = Math.abs(x - activeFragment.sourceX) < 10 && Math.abs(y - activeFragment.sourceY) < 10;
            const inBottomRight = Math.abs(x - (activeFragment.sourceX + activeFragment.width)) < 10 &&
                                  Math.abs(y - (activeFragment.sourceY + activeFragment.height)) < 10;

            if (inScalePoint || inBottomRight) {
                isResizing = true;
                isResizingPoint = inScalePoint;
                isResizingTopLeft = false;
            } else if (inTopLeft) {
                isResizing = true;
                isResizingTopLeft = true;
                isResizingPoint = false;
            } else if (inCenter) {
                isDragging = true;
                dragStartX = x - activeFragment.sourceX;
                dragStartY = y - activeFragment.sourceY;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!activeFragment || activeFragment.locked) return;
            const sourceRect = sourceCanvas.getBoundingClientRect();
            const targetRect = targetCanvas.getBoundingClientRect();
            const displayScaleX = targetCanvas.width / renderCanvasWidth;
            const displayScaleY = targetCanvas.height / renderCanvasHeight;

            if (isDragging) {
                const x = (e.clientX - sourceRect.left) * (video.videoWidth / sourceCanvas.width);
                const y = (e.clientY - sourceRect.top) * (video.videoHeight / sourceCanvas.height);
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'sourceX', oldValue: activeFragment.sourceX });
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'sourceY', oldValue: activeFragment.sourceY });
                activeFragment.sourceX = Math.max(0, Math.min(x - dragStartX, video.videoWidth - activeFragment.width));
                activeFragment.sourceY = Math.max(0, Math.min(y - dragStartY, video.videoHeight - activeFragment.height));
                renderSourceFrame();
                updateFragmentControls();
            } else if (isResizing) {
                const x = (e.clientX - sourceRect.left) * (video.videoWidth / sourceCanvas.width);
                const y = (e.clientY - sourceRect.top) * (video.videoHeight / sourceCanvas.height);
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'width', oldValue: activeFragment.width });
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'height', oldValue: activeFragment.height });
                if (isResizingTopLeft) {
                    undoStack.push({ action: 'edit', fragment: activeFragment, key: 'sourceX', oldValue: activeFragment.sourceX });
                    undoStack.push({ action: 'edit', fragment: activeFragment, key: 'sourceY', oldValue: activeFragment.sourceY });
                    const newWidth = activeFragment.sourceX + activeFragment.width - x;
                    const newHeight = activeFragment.sourceY + activeFragment.height - y;
                    if (newWidth >= 10 && newHeight >= 10) {
                        activeFragment.sourceX = x;
                        activeFragment.sourceY = y;
                        activeFragment.width = newWidth;
                        activeFragment.height = newHeight;
                    }
                } else {
                    activeFragment.width = Math.max(10, Math.min(x - activeFragment.sourceX, video.videoWidth - activeFragment.sourceX));
                    activeFragment.height = Math.max(10, Math.min(y - activeFragment.sourceY, video.videoHeight - activeFragment.sourceY));
                }
                renderSourceFrame();
                updateFragmentControls();
            } else if (isDraggingTarget) {
                const x = (e.clientX - targetRect.left) / displayScaleX;
                const y = (e.clientY - targetRect.top) / displayScaleY;
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'x', oldValue: activeFragment.x });
                undoStack.push({ action: 'edit', fragment: activeFragment, key: 'y', oldValue: activeFragment.y });
                activeFragment.x = Math.max(0, Math.min(x - dragStartX, targetCanvasWidth - activeFragment.width * activeFragment.scale));
                activeFragment.y = Math.max(0, Math.min(y - dragStartY, targetCanvasHeight - activeFragment.height * activeFragment.scale));
                renderTargetFrame();
                updateFragmentControls();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            isResizing = false;
            isResizingPoint = false;
            isResizingTopLeft = false;
            isDraggingTarget = false;
        });

        targetCanvas.addEventListener('mousedown', (e) => {
            if (!activeFragment || activeFragment.locked) return;
            const rect = targetCanvas.getBoundingClientRect();
            const displayScaleX = targetCanvas.width / renderCanvasWidth;
            const displayScaleY = targetCanvas.height / renderCanvasHeight;
            const x = (e.clientX - rect.left) / displayScaleX;
            const y = (e.clientY - rect.top) / displayScaleY;

            const inCenter = x >= activeFragment.x && x <= activeFragment.x + activeFragment.width * activeFragment.scale &&
                             y >= activeFragment.y && y <= activeFragment.y + activeFragment.height * activeFragment.scale;

            if (inCenter) {
                isDraggingTarget = true;
                dragStartX = x - activeFragment.x;
                dragStartY = y - activeFragment.y;
            }
        });

        targetCanvas.addEventListener('wheel', (e) => {
            if (!activeFragment || activeFragment.locked) return;
            e.preventDefault();
            const delta = e.shiftKey ? (e.deltaY > 0 ? -0.1 : 0.1) : (e.deltaY > 0 ? -0.01 : 0.01);
            undoStack.push({ action: 'edit', fragment: activeFragment, key: 'scale', oldValue: activeFragment.scale });
            activeFragment.scale = roundToTwo(Math.max(0.1, activeFragment.scale + delta));
            renderTargetFrame();
            updateFragmentControls();
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                activeFragment = null;
                updateFragmentList();
                updateFragmentControls();
                renderSourceFrame();
                renderTargetFrame();
            } else if (e.ctrlKey && e.key === 'z') {
                undoAction();
            } else if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                togglePlayPause();
            }
        });

        previewPlayPauseBtn.addEventListener('click', togglePreview);
        function togglePreview() {
            if (isPreviewing) {
                video.pause();
                isPreviewing = false;
                previewPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i> Preview';
                cancelAnimationFrame(previewFrameId);
            } else {
                if (startTime >= endTime) {
                    status.textContent = 'Invalid time range.';
                    status.classList.add('error');
                    return;
                }
                video.currentTime = startTime;
                video.play().catch(() => {
                    status.textContent = 'Error playing video.';
                    status.classList.add('error');
                });
                isPreviewing = true;
                previewPlayPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Preview';
                previewClip();
            }
        }

        let previewFrameId;
        function previewClip() {
            if (!isPreviewing) return;
            if (video.currentTime >= endTime || video.paused) {
                video.pause();
                isPreviewing = false;
                previewPlayPauseBtn.innerHTML = '<i class="fas fa-play"></i> Preview';
                cancelAnimationFrame(previewFrameId);
                return;
            }
            previewSeek.value = video.currentTime;
            previewTime.textContent = formatTime(video.currentTime);
            renderTargetFrame();
            previewFrameId = requestAnimationFrame(previewClip);
        }

        previewSeek.addEventListener('input', () => {
            video.currentTime = parseFloat(previewSeek.value);
            renderTargetFrame();
        });

        exportBtn.addEventListener('click', processVideo);
        async function processVideo() {
            console.log('processVideo called');
            if (isExporting) {
                status.textContent = 'Export in progress, please wait.';
                status.classList.add('error');
                return;
            }
            if (startTime >= endTime) {
                status.textContent = 'Invalid time range.';
                status.classList.add('error');
                return;
            }
            if (!video.src) {
                status.textContent = 'No video loaded.';
                status.classList.add('error');
                return;
            }

            isExporting = true;
            exportProgress.classList.add('active');
            exportProgress.textContent = 'Exporting: 0%';
            await cleanupExport();

            cancelExportBtn.style.display = 'inline-block';
            exportBtn.disabled = true;

            try {
                video.pause();
                video.currentTime = startTime;

                videoStream = hiddenCanvas.captureStream(30);
                console.log('Created video stream from hidden canvas');

                audioCtx = new AudioContext();
                console.log('Created new AudioContext');

                audioSource = audioCtx.createMediaElementSource(video);
                audioDestination = audioCtx.createMediaStreamDestination();
                audioSource.connect(audioDestination);
                audioStream = audioDestination.stream;
                console.log('Created new audio nodes and stream');

                const combinedStream = new MediaStream([
                    ...videoStream.getVideoTracks(),
                    ...audioStream.getAudioTracks()
                ]);

                recordedChunks = [];
                mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 10000000,
                    audioBitsPerSecond: 192000
                });
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.onstop = async () => {
                    console.log('MediaRecorder stopped, chunks:', recordedChunks.length);
                    exportProgress.classList.remove('active');
                    if (recordedChunks.length > 0) {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'output.webm';
                        a.click();
                        URL.revokeObjectURL(url);
                    } else {
                        status.textContent = 'Error: No data recorded.';
                        status.classList.add('error');
                    }
                    await cleanupExport();
                    isExporting = false;
                };
                mediaRecorder.onerror = (e) => {
                    console.error('MediaRecorder error:', e);
                    status.textContent = 'Error during recording.';
                    status.classList.add('error');
                    exportProgress.classList.remove('active');
                    cleanupExport();
                    isExporting = false;
                };

                console.log('Starting MediaRecorder');
                mediaRecorder.start(100);

                await video.play().catch(e => {
                    console.error('Video playback failed:', e);
                    throw new Error('Failed to play video');
                });

                let lastFrameTime = performance.now();
                function renderExportFrame() {
                    if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                        console.log('Stopping renderExportFrame');
                        return;
                    }
                    const currentTime = video.currentTime;
                    if (currentTime >= endTime) {
                        mediaRecorder.stop();
                        return;
                    }
                    const progress = Math.round(((currentTime - startTime) / (endTime - startTime)) * 100);
                    exportProgress.textContent = `Exporting: ${progress}%`;
                    renderTargetFrame();
                    const now = performance.now();
                    const delta = now - lastFrameTime;
                    lastFrameTime = now;
                    const delay = Math.max(0, (1000 / 30) - delta);
                    setTimeout(() => {
                        try {
                            requestAnimationFrame(renderExportFrame);
                        } catch (e) {
                            console.error('Error in requestAnimationFrame:', e);
                            mediaRecorder.stop();
                        }
                    }, delay);
                }

                video.ontimeupdate = () => {
                    if (video.currentTime >= endTime) {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                    }
                };

                const timeout = setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log('Timeout triggered, stopping MediaRecorder');
                        mediaRecorder.stop();
                    }
                    cleanupExport();
                    isExporting = false;
                }, (endTime - startTime + 10) * 1000);

                requestAnimationFrame(renderExportFrame);
            } catch (error) {
                console.error('Export failed:', error);
                status.textContent = `Export failed: ${error.message}`;
                status.classList.add('error');
                exportProgress.classList.remove('active');
                await cleanupExport();
                isExporting = false;
            }
        }
cancelExportBtn.addEventListener('click', async () => {
    console.log('Cancel export clicked');
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    video.pause();
    exportProgress.classList.remove('active');
    await cleanupExport();
    isExporting = false;
});

async function cleanupExport() {
    console.log('Cleaning up export resources');

    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        console.log('Stopping MediaRecorder in cleanup');
        mediaRecorder.stop();
        await new Promise(resolve => setTimeout(resolve, 1000));
    }
    mediaRecorder = null;
    recordedChunks = [];

    if (audioSource) {
        try {
            audioSource.disconnect();
            console.log('AudioSource disconnected');
        } catch (e) {
            console.error('Error disconnecting AudioSource:', e);
        }
        audioSource = null;
    }
    if (audioDestination) {
        try {
            audioDestination.disconnect();
            console.log('AudioDestination disconnected');
        } catch (e) {
            console.error('Error disconnecting AudioDestination:', e);
        }
        audioDestination = null;
    }
    if (audioCtx && audioCtx.state !== 'closed') {
        try {
            await audioCtx.close();
            console.log('AudioContext closed');
        } catch (e) {
            console.error('Error closing AudioContext:', e);
        }
        audioCtx = null;
    }
    if (videoStream) {
        videoStream.getTracks().forEach(track => {
            if (track.readyState === 'live') {
                track.stop();
                console.log('Video track stopped');
            }
        });
        videoStream = null;
    }
    if (audioStream) {
        audioStream.getTracks().forEach(track => {
            if (track.readyState === 'live') {
                track.stop();
                console.log('Audio track stopped');
            }
        });
        audioStream = null;
    }

    reinitializeVideoElement();

    cancelExportBtn.style.display = 'none';
    exportBtn.disabled = false;
    console.log('Export button enabled:', !exportBtn.disabled);
    video.ontimeupdate = null;
    status.textContent = 'Export completed or cancelled.';
    status.classList.remove('error');

    exportBtn.removeEventListener('click', processVideo);
    exportBtn.addEventListener('click', processVideo);
    console.log('Export button click event rebound');
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        activeFragment = null;
        updateFragmentList();
        updateFragmentControls();
        renderSourceFrame();
        renderTargetFrame();
    } else if (e.ctrlKey && e.key === 'z') {
        undoAction();
    } else if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
        e.preventDefault();
        togglePlayPause();
    }
});

function undoAction() {
    const action = undoStack.pop();
    if (!action) return;

    if (action.action === 'add') {
        fragments = fragments.filter(f => f !== action.fragment);
    } else if (action.action === 'remove') {
        fragments.splice(action.index, 0, action.fragment);
    } else if (action.action === 'edit') {
        action.fragment[action.key] = action.oldValue;
    } else if (action.action === 'lock') {
        action.fragment.locked = action.oldLocked;
    } else if (action.action === 'import') {
        fragments = fragments.filter(f => !action.fragments.includes(f));
    } else if (action.action === 'reset-timings') {
        action.timings.forEach(({ fragment, start, end, bindStart, bindEnd }) => {
            fragment.start = start;
            fragment.end = end;
            fragment.bindStart = bindStart;
            fragment.bindEnd = bindEnd;
        });
    }

    activeFragment = fragments.includes(activeFragment) && !activeFragment.locked ? activeFragment : fragments.find(f => !f.locked) || null;
    updateFragmentList();
    updateTimeline();
    renderSourceFrame();
    renderTargetFrame();
}

renderSourceFrame();
renderTargetFrame();
bindVideoEvents();
</script>
</body>
</html>